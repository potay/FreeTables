<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_y2ebs19szgil-0>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-0,decimal) ". "}ol.lst-kix_r0a5c0cx41f6-0.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-0 0}.lst-kix_hoyeum9qvszp-2>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-2}.lst-kix_y2ebs19szgil-2>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-2,lower-roman) ". "}.lst-kix_r0a5c0cx41f6-0>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-0,decimal) ". "}.lst-kix_r0a5c0cx41f6-1>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-1,lower-latin) ". "}.lst-kix_y2ebs19szgil-3>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-3,decimal) ". "}.lst-kix_y2ebs19szgil-4>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-4,lower-latin) ". "}ol.lst-kix_r0a5c0cx41f6-3{list-style-type:none}.lst-kix_r0a5c0cx41f6-2>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-2,lower-roman) ". "}ol.lst-kix_r0a5c0cx41f6-2{list-style-type:none}.lst-kix_r0a5c0cx41f6-3>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-3,decimal) ". "}.lst-kix_y2ebs19szgil-7>li{counter-increment:lst-ctn-kix_y2ebs19szgil-7}ol.lst-kix_r0a5c0cx41f6-5{list-style-type:none}ol.lst-kix_r0a5c0cx41f6-4{list-style-type:none}ol.lst-kix_hoyeum9qvszp-1.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-1 0}.lst-kix_y2ebs19szgil-5>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-5,lower-roman) ". "}ol.lst-kix_r0a5c0cx41f6-1{list-style-type:none}ol.lst-kix_r0a5c0cx41f6-0{list-style-type:none}ol.lst-kix_y2ebs19szgil-7.start{counter-reset:lst-ctn-kix_y2ebs19szgil-7 0}ol.lst-kix_r0a5c0cx41f6-3.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-3 0}ol.lst-kix_y2ebs19szgil-1.start{counter-reset:lst-ctn-kix_y2ebs19szgil-1 0}.lst-kix_y2ebs19szgil-1>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-1,lower-latin) ". "}ol.lst-kix_y2ebs19szgil-4.start{counter-reset:lst-ctn-kix_y2ebs19szgil-4 0}ol.lst-kix_r0a5c0cx41f6-6.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-6 0}.lst-kix_r0a5c0cx41f6-6>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-6,decimal) ". "}.lst-kix_r0a5c0cx41f6-7>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-7,lower-latin) ". "}.lst-kix_hoyeum9qvszp-0>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-0}.lst-kix_r0a5c0cx41f6-4>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-4,lower-latin) ". "}.lst-kix_r0a5c0cx41f6-5>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-5,lower-roman) ". "}.lst-kix_r0a5c0cx41f6-8>li:before{content:"" counter(lst-ctn-kix_r0a5c0cx41f6-8,lower-roman) ". "}.lst-kix_hoyeum9qvszp-3>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-3}.lst-kix_y2ebs19szgil-6>li{counter-increment:lst-ctn-kix_y2ebs19szgil-6}.lst-kix_hoyeum9qvszp-5>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-5}ol.lst-kix_hoyeum9qvszp-6.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-6 0}.lst-kix_r0a5c0cx41f6-7>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-7}ol.lst-kix_r0a5c0cx41f6-2.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-2 0}ol.lst-kix_y2ebs19szgil-2.start{counter-reset:lst-ctn-kix_y2ebs19szgil-2 0}.lst-kix_r0a5c0cx41f6-1>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-1}ol.lst-kix_r0a5c0cx41f6-8.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-8 0}.lst-kix_r0a5c0cx41f6-8>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-8}.lst-kix_r0a5c0cx41f6-2>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-2}.lst-kix_y2ebs19szgil-8>li{counter-increment:lst-ctn-kix_y2ebs19szgil-8}ol.lst-kix_hoyeum9qvszp-0.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-0 0}.lst-kix_y2ebs19szgil-5>li{counter-increment:lst-ctn-kix_y2ebs19szgil-5}ol.lst-kix_y2ebs19szgil-3.start{counter-reset:lst-ctn-kix_y2ebs19szgil-3 0}ol.lst-kix_hoyeum9qvszp-7.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-7 0}.lst-kix_y2ebs19szgil-2>li{counter-increment:lst-ctn-kix_y2ebs19szgil-2}.lst-kix_y2ebs19szgil-8>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-8,lower-roman) ". "}.lst-kix_y2ebs19szgil-6>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-6,decimal) ". "}ol.lst-kix_r0a5c0cx41f6-7{list-style-type:none}ol.lst-kix_r0a5c0cx41f6-6{list-style-type:none}.lst-kix_y2ebs19szgil-7>li:before{content:"" counter(lst-ctn-kix_y2ebs19szgil-7,lower-latin) ". "}ol.lst-kix_r0a5c0cx41f6-8{list-style-type:none}ol.lst-kix_r0a5c0cx41f6-1.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-1 0}ol.lst-kix_y2ebs19szgil-8{list-style-type:none}ol.lst-kix_y2ebs19szgil-7{list-style-type:none}ol.lst-kix_y2ebs19szgil-6{list-style-type:none}ol.lst-kix_y2ebs19szgil-5{list-style-type:none}.lst-kix_r0a5c0cx41f6-4>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-4}ol.lst-kix_y2ebs19szgil-4{list-style-type:none}.lst-kix_hoyeum9qvszp-8>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-8,lower-roman) ". "}ol.lst-kix_y2ebs19szgil-3{list-style-type:none}.lst-kix_hoyeum9qvszp-8>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-8}ol.lst-kix_y2ebs19szgil-2{list-style-type:none}ol.lst-kix_y2ebs19szgil-1{list-style-type:none}ol.lst-kix_y2ebs19szgil-0{list-style-type:none}ol.lst-kix_hoyeum9qvszp-3{list-style-type:none}.lst-kix_hoyeum9qvszp-6>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-6,decimal) ". "}ol.lst-kix_hoyeum9qvszp-4{list-style-type:none}ol.lst-kix_hoyeum9qvszp-1{list-style-type:none}.lst-kix_hoyeum9qvszp-5>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-5,lower-roman) ". "}.lst-kix_hoyeum9qvszp-7>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-7,lower-latin) ". "}ol.lst-kix_hoyeum9qvszp-2{list-style-type:none}ol.lst-kix_hoyeum9qvszp-7{list-style-type:none}ol.lst-kix_hoyeum9qvszp-8{list-style-type:none}ol.lst-kix_hoyeum9qvszp-5{list-style-type:none}ol.lst-kix_r0a5c0cx41f6-7.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-7 0}ol.lst-kix_hoyeum9qvszp-6{list-style-type:none}ol.lst-kix_hoyeum9qvszp-0{list-style-type:none}.lst-kix_y2ebs19szgil-1>li{counter-increment:lst-ctn-kix_y2ebs19szgil-1}ol.lst-kix_hoyeum9qvszp-8.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-8 0}.lst-kix_r0a5c0cx41f6-5>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-5}ol.lst-kix_y2ebs19szgil-5.start{counter-reset:lst-ctn-kix_y2ebs19szgil-5 0}.lst-kix_hoyeum9qvszp-6>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-6}ol.lst-kix_hoyeum9qvszp-2.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-2 0}ol.lst-kix_hoyeum9qvszp-5.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-5 0}.lst-kix_hoyeum9qvszp-2>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-2,lower-roman) ". "}.lst-kix_hoyeum9qvszp-1>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-1,lower-latin) ". "}.lst-kix_hoyeum9qvszp-3>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-3,decimal) ". "}.lst-kix_y2ebs19szgil-3>li{counter-increment:lst-ctn-kix_y2ebs19szgil-3}.lst-kix_hoyeum9qvszp-0>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-0,decimal) ". "}.lst-kix_hoyeum9qvszp-4>li:before{content:"" counter(lst-ctn-kix_hoyeum9qvszp-4,lower-latin) ". "}.lst-kix_y2ebs19szgil-0>li{counter-increment:lst-ctn-kix_y2ebs19szgil-0}ol.lst-kix_y2ebs19szgil-8.start{counter-reset:lst-ctn-kix_y2ebs19szgil-8 0}ol.lst-kix_y2ebs19szgil-6.start{counter-reset:lst-ctn-kix_y2ebs19szgil-6 0}ol.lst-kix_hoyeum9qvszp-3.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-3 0}.lst-kix_y2ebs19szgil-4>li{counter-increment:lst-ctn-kix_y2ebs19szgil-4}ol.lst-kix_r0a5c0cx41f6-5.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-5 0}.lst-kix_hoyeum9qvszp-1>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-1}.lst-kix_r0a5c0cx41f6-6>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-6}ol.lst-kix_r0a5c0cx41f6-4.start{counter-reset:lst-ctn-kix_r0a5c0cx41f6-4 0}.lst-kix_hoyeum9qvszp-4>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-4}.lst-kix_hoyeum9qvszp-7>li{counter-increment:lst-ctn-kix_hoyeum9qvszp-7}.lst-kix_r0a5c0cx41f6-3>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-3}ol.lst-kix_hoyeum9qvszp-4.start{counter-reset:lst-ctn-kix_hoyeum9qvszp-4 0}ol.lst-kix_y2ebs19szgil-0.start{counter-reset:lst-ctn-kix_y2ebs19szgil-0 0}.lst-kix_r0a5c0cx41f6-0>li{counter-increment:lst-ctn-kix_r0a5c0cx41f6-0}ol{margin:0;padding:0}table td,table th{padding:0}.c8{font-size:18pt;font-family:"Times New Roman";font-weight:bold}.c0{font-size:12pt;font-family:"Times New Roman";font-weight:bold}.c10{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c1{orphans:2;widows:2;height:11pt}.c2{font-size:12pt;font-family:"Times New Roman"}.c6{margin-left:36pt;padding-left:0pt}.c12{color:inherit;text-decoration:inherit}.c11{color:#1155cc;text-decoration:underline}.c7{padding:0;margin:0}.c4{padding-top:10pt;line-height:0.9}.c3{orphans:2;widows:2}.c13{color:#505050}.c5{font-style:italic}.c9{text-align:center}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c10"><p class="c3 c9"><span class="c8">Performance Analysis of Lock Free Hash Table</span></p><p class="c3 c9"><span class="c2">Paul Chun(pchun1), &nbsp; Mark Fernandez(msfernan)</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">Summary</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c2">We implemented a lock-free hash table using lock-free linked lists. We found out that a lock-free hash-table without memory management improves performance at high thread counts as opposed to a lock-free hash table with locks per list. While a lock-free linked list with memory management shows an improved performance, our lock-free hash table with memory management would need further optimizations to match the performance of a lock-free hash-table without memory management. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c0">Background</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c2">For our application. We implemented a lock-free hash table using separate chaining. The following is a diagram of a hash table. Each key hashes to a specific bucket in our hash table. At each bucket is stored a linked list composed of all the keys that hashed to that specific bucket. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 440.00px;"><img alt="Screen Shot 2016-05-08 at 12.34.08 PM.png" src="images/image01.png" style="width: 624.00px; height: 440.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">In order to make this hash table lock free, we had to make each of the linked lists that form the hash table lock-free. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">There are two ways by which we go about doing this. </span></p><p class="c1"><span class="c2"></span></p><ol class="c7 lst-kix_y2ebs19szgil-0 start" start="1"><li class="c6 c3"><span class="c2">Lock based linked list: Each operation takes a lock on the linked list before attempting to perform and operation on the list.</span></li><li class="c6 c3"><span class="c2">Lock free linked list: We implemented a lock-free linked lists using atomic operations. Our implementation was based on the lock-free linked list used by Michael Maged. It consists to of using private prev, curr and next pointers to compute changes in state and using atomic CAS (compare and swap) operations to make these changes visible to all the other threads operating on the shard data structure. </span></li></ol><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">The following operations are supported in our hash table. </span></p><p class="c1"><span class="c2"></span></p><ol class="c7 lst-kix_r0a5c0cx41f6-0 start" start="1"><li class="c3 c6"><span class="c2">Insert- Inserts a node at the correct bucket at the correct location in the linked lists. The linked list in maintained in sorted order by key. </span></li><li class="c6 c3"><span class="c2">Delete- Deletes a node from the correct bucket from the linked list belonging to that bucket. The algorithms does this by using CAS &nbsp;operations to mark a node and deleted so that other nodes do not link to it and then using CAS operations to delete the node. </span></li><li class="c6 c3"><span class="c2">Search- Search returns true if the node is found in the bucket and false otherwise. </span></li></ol><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Insert, Delete and Search make use of a private method find that scans through the linked list and returns true if the node is found at a particular location in the linked list. Find &nbsp;guarantees that the linked list captures a snapshot of the linked list in the prev, curr and next pointers that includes the node (if any) that contains the lowest key value greater than or equal to the input key and its predecessor pointer. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">A workload of operations consisting of inserts, deletes and searches is data parallel as different threads can operate on different buckets in the hash table in parallel. </span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c0">Approach</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c2">As mentioned, we decided to develop the project in C++ in order to keep </span><span class="c2 c13">, </span><span class="c2">as it allowed us to create more robust data structures in order to keep the code tidy and readable, whilst allowing the implementation to be efficient and clean. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Machines targeted. Michael used a Michael used &nbsp;a 4-processor (375 MHz604e) IBM PowerPC capable of running 4 superscalar instructions to run his implementation. We developed our on the linux machines that had fewer execution contexts. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">We started off by creating a sequential test harness and a linked list with a global lock. &nbsp;Following this &nbsp;moved on to creating a lock-free linked list.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Moved on to creating a parallel test &nbsp;harness. We implemented a barrier class so that we could perform insert operations, synchronize all inserts to complete tests, perform delete operations, synchronize all tests to complete and then perform search operations. Thus we could tell whether the state of our list was what we expected. When we tested for performance however, we removed all the synchronization and mixed up the inserts, deletes and removes. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Moved on to implementing SMR (Safe Memory Reclamation) as a safe memory management technique for the linked list. We do this by associating a shared array of hazard pointers with operating threads. &nbsp;Before deleting from a linked list, we check if any of the hazard pointers from the shared array point to the node we want to delete. If any hazard pointer does point to the node we wish to remove, then we delete the node later. We also delete all the nodes that may not have had a chance to be deleted after the implementation completes. In order to test that each allocated node was deleted, we printed kept a count of each node deleted by each thread and checked if the total nodes deleted matched the total nodes inserted. We also ran valgrind to check for memory leaks. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Finally, we implemented a hash table using our linked lists. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c0">Results: Description of testing</span><span class="c2">&nbsp;</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">We measured the amount of time in seconds taken by the CPU to execute a workload of 10,0000 instructions with &nbsp;4, 8, 16 and 32 threads respectively . The workload was composed of &#8531; insert operations, &#8531; delete operations and &#8531; search operations. The insert, delete and search operations were randomly generated. Each operation is put into a file. When parsing the file, each operations is put into a work queue. The threads pull work from this shared queue and run them. &nbsp;This workload was similar to one of the workloads tested by Michael Maged in his implementation of a lock-free hash table. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">This workload was run using the different data structures used in our implementation. We measured this time taken for a lock-free linked list with safe memory management to complete this workload and compared it to the time taken by &nbsp;a linked list with a global lock. We also measured the time taken to complete this workload by a lock-free hash table without memory management to the time taken by a lock-free hash table with safe memory reclamation and the time taken by a hash table with locks per linked list . </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">The time taken to complete this workload was the average time of 5 runs. In order to speed up the performance, we removed all logging code that we used to check correctness. We used several smaller workloads (such as 1000 operations) but the time taken for &nbsp;each of the data structures was roughly the same. Our implementation requires more optimizations/a different architecture to run larger workloads effectively. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Michael used &nbsp;a 4-processor (375 MHz604e) IBM PowerPC to run his implementation &nbsp;which provided. This processor can issue 4 superscalar instructions so it makes sense that he tested with 16 to 32 threads. We tested and developed on the linux machines which has only four execution contexts. Therefore, we expect our results to differ from that of Michael. We also will not be to run a workload as large as Michaels as our code will be slower than his due to the machine we are running on. Nevertheless we expected a speedup using our lock-free data structures.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">We use the std::hash function provided by the C++ library in order to ensure that the elements are uniformly distributed throughout the hash table.</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c0">Results: Description of performance</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">We found out that our Lock Free Linked List improves performance at high thread counts. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 561.50px; height: 314.18px;"><img alt="" src="images/image00.png" style="width: 561.50px; height: 314.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c2">&nbsp;</span></p><p class="c3"><span class="c0 c5">Figure: Lock-Free Linked list with &nbsp;improves performance versus locked.</span></p><p class="c1"><span class="c0 c5"></span></p><p class="c3"><span class="c2">We also found out that our lock-free hash table without memory management improves performance at high thread counts.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 572.00px; height: 330.50px;"><img alt="" src="images/image02.png" style="width: 572.00px; height: 330.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c0 c5">Figure: Lock-Free Hash Table without memory management improves performance </span></p><p class="c3"><span class="c2">Once we added in the SMR memory management &nbsp;however, we did not get a sufficient improvement over the hash table with locked lists. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 613.09px; height: 305.50px;"><img alt="" src="images/image03.png" style="width: 613.09px; height: 305.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0 c5">Figure: Lock Free hash table with memory management needs further optimization.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Although the performance of the lock-free hash-table with memory management is not as good as the lock-free or even the locked lists case, we know how to make it better. The Safe memory management technique involves associating a shared hazard pointer array with each participating thread. Our algorithm is O(N^2) in terms of the length of the shared hazard pointer array. Michael uses an algorithm that is O(NlogN) that we should have implemented. In addition, at high levels of threads counts we have contention that reduces performance. This can be rectified by cache-line padding our hash-table as Michael did. We could also implement atomic compare and swap using assembly as opposed to using the C++ primitives. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c0">References</span></p><p class="c4 c3"><span class="c2">Michael Maged: High Performance Dynamic Lock-Free Hash Tablesand List-Based Sets</span><span class="c2 c5">, In Proceedings of the 14th Annual ACM Symposium on Parallel Algorithms and Architectures, August 2002</span></p><p class="c3 c4"><span class="c2">Michael Maged: Safe Memory Reclamation for Dynamic Lock-Free Objects Using Atomic Reads and Writes</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2 c11"><a class="c12" href="https://www.google.com/url?q=http://www.nxp.com/files/32bit/doc/data_sheet/MPC604E.pdf&amp;sa=D&amp;ust=1462831187704000&amp;usg=AFQjCNGF_-mtRClZhnrE20MeQvU-0NLmkQ">http://www.nxp.com/files/32bit/doc/data_sheet/MPC604E.pdf</a></span></p><p class="c3"><span class="c0">Work by each student</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c2">Equal work was performed by each student.</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><div><p class="c1"><span></span></p></div></body></html>